type protocolo = HTTP | SMTP | FTP
type enlace = TRESG | ETH | WIFI

node enlace(status: bool) returns (estado:int)
let
    automaton

        state OFF do
            estado = 0;
        unless not status then ON

        state ON do
            estado = 1;
        unless status then OFF

    end
tel

node protocolos(nota_http, nota_smtp, nota_ftp: int) returns (estado: protocolo; melhor_valor:int)
let
    automaton

        state HTTP do
            estado = HTTP;
            melhor_valor = nota_http;
        unless nota_ftp >= nota_http then FTP
            | nota_smtp >= nota_http then SMTP

        state FTP do
            estado = FTP;
            melhor_valor = nota_ftp;
        unless nota_http >= nota_ftp then HTTP
            | nota_smtp >= nota_ftp then SMTP

        state SMTP do
            estado = SMTP;
            melhor_valor = nota_smtp;
        unless nota_ftp >= nota_smtp then FTP
            | nota_http >= nota_smtp then SMTP

    end
tel

node decisor(c1, c2, c3: bool) returns (estado: int)
let
    automaton

        state ETHERNET do
            estado = 0;
        unless c1 then TresG
            | c3 then WIFI

        state TresG do
            estado = 1;
        unless c2 then ETHERNET
            | c3 then WIFI

        state WIFI do
            estado = 2;
        unless c1 then TresG
            | c2 then ETHERNET

    end
tel

node canal(c: bool) returns(estado: bool)
let
    automaton
    
        state OFF do
            estado = false;
        unless c then ON
        
        state ON do
            estado = true;
        unless not c then OFF
        
    end
tel

node controlador_multihomed(status_3g, status_wf, status_eth: bool; nota_http3g, nota_smtp3g, nota_ftp3g, nota_httpwf, nota_smtpwf, nota_ftpwf, nota_httpeth, nota_smtpeth, nota_ftpeth: int) returns (estado_3g, valor_3g, estado_wf, valor_wf, estado_eth, valor_eth, melhor_enlace: int; prot_3g, prot_wf, prot_eth: protocolo)
    contract
        var regra, melhor_3g, melhor_eth, melhor_wf: bool;
        let
            melhor_3g = ((estado_3g = 1) & ((valor_3g >= valor_wf) & (valor_3g >= valor_eth)));
            melhor_eth = ((estado_eth = 1) & ((valor_eth >= valor_wf) & (valor_eth >= valor_3g)));
            melhor_wf = ((estado_wf = 1) & ((valor_wf >= valor_3g) & (valor_wf >= valor_eth)));
            regra = (melhor_enlace = 0);
            
            if melhor_3g = true
            then regra = (melhor_enlace = 1)
            else regra = (melhor_enlace = 2)
            end
        tel
        enforce regra
            with(c1, c2, c3: bool)
let
    estado_3g = enlace(status_3g);
    (prot_3g, valor_3g) = protocolos(nota_http3g, nota_smtp3g, nota_ftp3g);
    estado_wf = enlace(status_wf);
    (prot_wf, valor_wf) = protocolos(nota_httpwf, nota_smtpwf, nota_ftpwf);
    estado_eth = enlace(status_eth);
    (prot_eth, valor_eth) = protocolos(nota_httpeth, nota_smtpeth, nota_ftpeth);
    melhor_enlace, melhor_prot = decisor(estado_3g, prot_3g, valor_3g, estado_eth, prot_eth, valor_eth, estado_wf, prot_wf, valor_wf);
tel

(*
contract
        var
            rule1, rule2, rule3, rule4, regra5: bool;
        total: int;
        let
        rule1 = not room_oc or (lamp_on or tv_on);
        rule2 = room_oc or not (window_open or door_open);
        rule3 = not (window_open or door_open) or (nameRad = 0 or nameRad = 1);
        rule4 = room_oc or (not(lamp_on or tv_on) & (powerRad = 0 or powerRad = 300));
        total = powerOven + powerRad + powerWash;
        switch s | S1 do regra5 = (total <= 3000)
                    | S2 do regra5 = (total <= 5000)
                    | S3 do regra5 = (total <= 7000);
        end
        tel
        enforce rule1 & rule2 & rule3 & rule4 & regra5
            with (c_door, c_window, c1, c2, c_wash, c_oven, contLamp1, contLamp2, contTV1, contTV2: bool)
*)
